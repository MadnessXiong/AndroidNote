### 1. 对象何时被回收

- 引用计数器算法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1，引用失效时减1。当值为0时，代表对象不可能再被使用。

  引用计数器算法实现简单，判定效率也高，但是无法解决对象之间相互循环引用的问题，主流Java虚拟机都没有采用这个算法。

- 可达性分析算法：可达性分析算法通过一系列GC Roots的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到这个对象不可达）时，证明此对象是不可用的。

  Java中可作为GC Roots的对象包括下面几种

  - 虚拟机栈（栈中的局部变量表）中引用的对象
  - Java中静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI引用的对象

- 对象的死亡：即使在可达性分析算法中不可达的对象，也并不是非死不可的。这时候他们正处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize()。当对象没有覆盖finalize()或者finalize()已经被虚拟机调用过，虚拟机将这2种情况都视为没有必要执行。

  如果这个对象被判定为有必要执行finallize()，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里所谓的执行是指虚拟机会触发这个方法，但并不会承诺等待它运行结束。这样做的原因是，如果一个对象在finalize()中执行缓慢或者发生了死循环，就可能导致F-Queue处于永远等待状态。甚至导致整个内存回收系统崩溃

  finalize()是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中拯救自己，只要重新与引用链上任意一个对象建立关联即可。

### 2. 引用的类型

JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱

- 强引用：强引用就是指在代码中普遍存在的引用，如new出的对象，这类的引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象
- 软引用：软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统即将发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出异常。JDK1.2之后，提供了SoftReference类来实现软引用。
- 弱引用：弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。JDK1.2之后，提供了WeakReference类来实现弱引用。
- 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后，提供了PhantomReference来实现虚引用

### 3. 垃圾收集算法

- 标记-清除算法：标记清除算法分为标记和清除2个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的标记过程就是之前提到过可达性分析算法。

  标记清除算法有2个不足：一是效率问题，标记和清除效率都不高，另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片过多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

- 复制算法：复制算法将可用内存按容量划分为大小相等的2块，每次只使用其中一块。当这一块的内存用完了，就将还存活着对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等情况，只要移动堆顶置针，按顺序分配内存即可，实现简单，运行高效。只是这种算法将内存缩小为了原来的一半。

  新生代用到了复制算法

- 标记-整理算法：标记整理算法的标记过程和标记清除算法一样。但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

  老年代使用了标记整理算法

- 分代收集算法：分代收集算法根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记清理或标记整理算法来进行回收。

### 4. 内存分配与回收策略

**堆的内存一般分为新生代和老年代，其中新生代又分为一个Eden区和2个Survivor区**

- 新生代：大多数情况下，对象在新生代Eden区中分配。当Eden区中没有足够空间分配时，虚拟机将发起一次MInor GC。

  当发起一次GC，Eden中存活对象就会被移动到第一块Survivor space s1(Survivor From)中。然后Eden被清空。等Eden再满了，再触发一次Minor GC，Eden和Survivor space s1中存活的对象又被移动到Survivor space s2(Survivor To)中，然后Eden和s1被清空。然后这时s1已空，它变成了Survivor From，s2变成了Survivor To。等再次发起Gc时重复以上过程

  

- 老年代：对象每被移动到Survivor空间一次，年龄就加1，当它的年龄增加到一定程度（默认15岁，可设置），就将晋升到老年代中。

  大对象会直接进入老年代，所谓大对象是指需要大量连续内存空间大Java对象，最典型的大对象就是那种很长的字符串及数组。所以一般应该避免创建那种朝生夕死的短命大对象。

  虚拟机并不是永远要求对象年龄必须达到设置的默认值才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。