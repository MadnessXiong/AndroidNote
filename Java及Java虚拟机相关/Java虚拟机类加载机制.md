### 1. 类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止它的整个生命周期包括：加载（loading），验证（Verification），准备（Preoaration），解析（Resolution），初始化（Initalization），使用（Using）和卸载（Unloading）7个阶段。其中验证，准备，解析3个部分统称为连接。

* 遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。

* 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化则需要先触发其初始化

* 当初始化一个类的时候，如果发现其父类没有进行过初始化，则需要先触发其父类初始化

* 当虚拟机启动时，需要用户指定一个执行的主类（包含Main()的那个类），虚拟机会先初始化这个主类

* 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的句柄方法，并且这个方法句柄所对应的类没有进行过初始化，则先需要出发其初始化。

**有且只有以上5种场景中的行为会触发类的初始化，这5种场景称为对一个类的主动引用。除此之外，所有引用类的方式都不会出发初始化，称为被动引用。接口和类的区别是，一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候，才会初始化**

被动引用的例子：
```
//父类
public class SuperClass {
    
    static {
        System.out.println("初始化SuperCLass");
    }
    //父类静态方法
    public static void init(){}
  	//常量
    public static final String INIT="init";
		
}
//子类
public class SubClass extends SuperClass{

    static {
        System.out.println("初始化SuperCLass");
    }
}
//通过子类调用父类静态方法
 SubClass.init();
//数组
SuperClass[] superClasses = new SuperClass[1];
//引用常量
System.out.println(SuperClass.INIT);
```
以上代码中调用SubClass.init()后不会触发子类的初始化

- 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态方法，只会触发父类的初始化，而不会触发子类的初始化。
- 同样构建一个类的数组也不会触发其初始化。（虚拟机会生成另外一个类，这里不展开。）
- 引用常量也不会触发一个类的初始化，因为在编译阶段已经通过常量传播优化，将此常量的值存储到了调用它的类的常量池中，以后对此常量的引用直接转化为了调用它的类对自身常量池的引用

### 2. 类加载的过程（这里只关注准备及初始化阶段）

* 准备阶段：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这些变量指的是类变量，也就是被static修饰的变量，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。同样这里的初始值指的是数据类型的零值，而不是代码中的赋值。
初始化阶段：初始化时类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的Java程序代码。在这个阶段，会根据程序员的计划去初始化类变量和其他资源。

* 初始化阶段是执行类构造器clinit():
   * clinit()是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前到变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。

  * clinit()与类的构造函数（或者说实例构造起init()）不同，它不需要显示地调用父类构造器，虚拟机会保证子类的clinit()方法执行之前父类的clinit()方法已经执行完毕。

  * 由于父类的clinit()先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作

  * clinit()方法对于类或者接口来说并不是必须的，如果一个类中没有静态语句块，也就没有对变量的赋值操作，那么编译器可以不为这个类生成clinit()

  * 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成clinit()。但接口与类不同的是，执行接口的clinit()不需要先执行父接口的clinit()。只有当父接口中定义的变量使用时，父接口才会初始化，另外接口的实现类在初始化时也一样不会执行接口的clinit()

  * 虚拟机会保证一个类的clinit()在多线程环境中被正确地加锁，同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit(),其他线程都需要阻塞等待，直到活动线程clinit()执行完毕。

```
public class SubClass extends SuperClass{
	
    static {
    	//可以给变量赋值
      I=1;
      //这句编译器会提示非法向前引用  
      System.out.println(""+i);
    }

    static int I=0;
}
```

### 4. 类加载器

* 类与类加载器：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性质。每一个类加载器，都拥有一个独立的类命名空间。比较2个类是否相等，只有在这2个类是由同一个类加载器加载的前提下才有意义，否则，即使这2个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这2个类就必定不相等

  这里相等包括代表类的Class对象的equals(),isAssignableForm(),isInstance()的返回结果。也包括使用instanceof关键字做对象所属关系判定等情况

  从Java开发人员的角度讲，类加载器还可以化为分：
  
   * 启动类加载器：这个类加载器负责将存放在JAVA_HOME\lib中的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用null即可。

  * 扩展类加载器：它负责加载JAVA_HOME\lib\ext目录中的类库，开发者可以直接使用扩展类加载器
 
  * 应用程序类加载器（Application CLassLoader）：这个类加载器是CLassLoader中getSystemClassLoader()的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者直接可以使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器

应用程序都是由这3种类加载器互相配合进行加载的，如果有必要还可以加入自己定义的类加载器，它们的关系如下：
![image-20200119204213241.png](/work/learn/note/AndroidNote/Java及Java虚拟机相关/Res/image-20200119204213241.png)

类加载器之间的这种层次关系，称为加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器，这里的类加载器之间的父子关系一般使用组合关系来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

双亲委派模型保证了一个类无论哪一个类加载器加载，最终都会委派给最顶层的加载器去加载（除非找不到），这样就保证了这个类在各种类加载器环境中都是同一个类。				

  